//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by CodeGen v1.0.0-beta+2aba22e929803a296ead64d46c51322a032541ff
//     Script: generate-code.bat (or generate-code.sh for Unix)
//     Timestamp: 6/21/2025 1:35:02 PM
//     Template: AsyncOperations.template.cs
//     Target: Result (net8.0+)
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     regenerated. Consider modifying the template instead.
// </auto-generated>
//------------------------------------------------------------------------------

using System.Diagnostics;
using System.Runtime.CompilerServices;
using ZeroResult.Errors;

namespace ZeroResult;

public readonly partial struct Result<T, TError>
    where TError : IError
{
    /// <summary>
    /// Asynchronously maps the successful value to a new type using the provided mapper function.
    /// If the result is a failure, it returns the error unchanged.
    /// </summary>
    /// <typeparam name="TResult">The type of the mapped successful value.</typeparam>
    /// <param name="mapper">The async function to map the successful value.</param>
    /// <returns>A <see cref="ValueTask"/> representing the new <see cref="Result{TResult, TError}"/> with the mapped value or the original error.</returns>
    /// <exception cref="ArgumentNullException">Thrown when the mapper function is null.</exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public async ValueTask<Result<TResult, TError>> MapAsync<TResult>(Func<T, ValueTask<TResult>> mapper)
    {
        if (_isSuccess)
        {
            Debug.Assert(mapper is not null, "Mapper function should not be null.");
            Debug.Assert(_value is not null, "Value should not be null when mapping a success.");

            return new(await mapper(_value).ConfigureAwait(false));
        }

        Debug.Assert(_error is not null, "Error should not be null when mapping a failure.");

        return new(_error);
    }

    /// <summary>
    /// Asynchronously binds the successful value to a new <see cref="Result{TResult, TError}"/> using the provided binder function.
    /// If the result is a failure, it returns the error unchanged.
    /// </summary>
    /// <typeparam name="TResult">The type of the result value returned by the binder.</typeparam>
    /// <param name="binder">The async function to bind the successful value to a new result.</param>
    /// <returns>A <see cref="ValueTask"/> representing the new <see cref="Result{TResult, TError}"/> with the result of the binder or the original error.</returns>
    /// <exception cref="ArgumentNullException">Thrown when the binder function is null.</exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public async ValueTask<Result<TResult, TError>> BindAsync<TResult>(Func<T, ValueTask<Result<TResult, TError>>> binder)
    {
        if (_isSuccess)
        {
            Debug.Assert(binder is not null, "Binder function should not be null.");
            Debug.Assert(_value is not null, "Value should not be null when binding a success.");

            return await binder(_value).ConfigureAwait(false);
        }

        Debug.Assert(_error is not null, "Error should not be null when binding a failure.");

        return new(_error);
    }

    /// <summary>
    /// Asynchronously ensures that the successful value satisfies a given predicate.
    /// If the predicate is not satisfied, it returns a new failure result with the provided error factory.
    /// If the result is a failure, it returns the error unchanged.
    /// </summary>
    /// <param name="predicate">The async predicate function to check the successful value.</param>
    /// <param name="errorFactory">The async function to create an error if the predicate is not satisfied.</param>
    /// <returns>A <see cref="ValueTask"/> representing the new <see cref="Result{T, TError}"/> with the original value if the predicate is satisfied, or a failure result if not.</returns>
    /// <exception cref="ArgumentNullException">Thrown when the predicate or error factory function is null.</exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public async ValueTask<Result<T, TError>> EnsureAsync(Func<T, ValueTask<bool>> predicate, Func<ValueTask<TError>> errorFactory)
    {
        Debug.Assert(predicate is not null, "Predicate function should not be null.");
        Debug.Assert(_value is not null, "Value should not be null when ensuring a success.");

        if (_isSuccess && await predicate(_value).ConfigureAwait(false) == false)
        {
            Debug.Assert(errorFactory is not null, "Error factory function should not be null.");

            return new(await errorFactory().ConfigureAwait(false));
        }

        return this;
    }

    /// <summary>
    /// Asynchronously executes an action if the result is successful.
    /// If the result is a failure, the action is not executed.
    /// </summary>
    /// <param name="action">The async action to execute on success.</param>
    /// <returns>A <see cref="ValueTask"/> representing the current <see cref="Result{T, TError}"/> instance.</returns>
    /// <exception cref="ArgumentNullException">Thrown when the action is null.</exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public async ValueTask<Result<T, TError>> OnSuccessAsync(Func<T, ValueTask> action)
    {
        if (_isSuccess)
        {
            Debug.Assert(action is not null, "Action should not be null.");
            Debug.Assert(_value is not null, "Value should not be null when executing action on success.");

            await action(_value).ConfigureAwait(false);
        }

        return this;
    }

    /// <summary>
    /// Asynchronously executes an action if the result is a failure.
    /// If the result is successful, the action is not executed.
    /// </summary>
    /// <param name="action">The async action to execute on failure.</param>
    /// <returns>A <see cref="ValueTask"/> representing the current <see cref="Result{T, TError}"/> instance.</returns>
    /// <exception cref="ArgumentNullException">Thrown when the action is null.</exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public async ValueTask<Result<T, TError>> OnFailureAsync(Func<TError, ValueTask> action)
    {
        if (_isSuccess == false)
        {
            Debug.Assert(action is not null, "Action should not be null.");
            Debug.Assert(_error is not null, "Error should not be null when executing action on failure.");

            await action(_error).ConfigureAwait(false);
        }

        return this;
    }

    /// <summary>
    /// Asynchronously matches the result, executing the appropriate function based on whether it is a success or failure.
    /// If the result is successful, it executes the <paramref name="onSuccess"/> function with the successful value.
    /// If the result is a failure, it executes the <paramref name="onFailure"/> function with the error.
    /// </summary>
    /// <typeparam name="TResult">The type of the result returned by the matching functions.</typeparam>
    /// <param name="onSuccess">The async function to execute if the result is successful.</param>
    /// <param name="onFailure">The async function to execute if the result is a failure.</param>
    /// <returns>A <see cref="ValueTask"/> representing the result of the executed function based on the result state.</returns>
    /// <exception cref="ArgumentNullException">Thrown when either <paramref name="onSuccess"/> or <paramref name="onFailure"/> is null.</exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public async ValueTask<TResult> MatchAsync<TResult>(Func<T, ValueTask<TResult>> onSuccess, Func<TError, ValueTask<TResult>> onFailure)
    {
        if (_isSuccess)
        {
            Debug.Assert(onSuccess is not null, "OnSuccess function should not be null.");
            Debug.Assert(_value is not null, "Value should not be null when matching a success.");

            return await onSuccess(_value).ConfigureAwait(false);
        }

        Debug.Assert(onFailure is not null, "OnFailure function should not be null.");
        Debug.Assert(_error is not null, "Error should not be null when matching a failure.");

        return await onFailure(_error).ConfigureAwait(false);
    }

    /// <summary>
    /// Asynchronously executes the appropriate action based on whether the result is a success or failure.
    /// If the result is successful, it executes the <paramref name="onSuccess"/> action with the successful value.
    /// If the result is a failure, it executes the <paramref name="onFailure"/> action with the error.
    /// </summary>
    /// <param name="onSuccess">The async action to execute if the result is successful.</param>
    /// <param name="onFailure">The async action to execute if the result is a failure.</param>
    /// <returns>A <see cref="ValueTask"/> representing the completion of the executed action.</returns>
    /// <exception cref="ArgumentNullException">Thrown when either <paramref name="onSuccess"/> or <paramref name="onFailure"/> is null.</exception>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public async ValueTask MatchAsync(Func<T, ValueTask> onSuccess, Func<TError, ValueTask> onFailure)
    {
        if (_isSuccess)
        {
            Debug.Assert(onSuccess is not null, "OnSuccess action should not be null.");
            Debug.Assert(_value is not null, "Value should not be null when executing action on success.");

            await onSuccess(_value).ConfigureAwait(false);
        }
        else
        {
            Debug.Assert(onFailure is not null, "OnFailure action should not be null.");
            Debug.Assert(_error is not null, "Error should not be null when executing action on failure.");

            await onFailure(_error).ConfigureAwait(false);
        }
    }
}
